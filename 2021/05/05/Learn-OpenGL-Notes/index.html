<!doctype html>
<html>
  <head>
    <link rel="icon" href="../source/_images/icon.png">
    
      <title>Learn OpenGL Notes </title>
    
    <style type="text/css">
      body {
        background-color: rgb(230, 230, 230);
        width: 70%;
        margin: auto;
        margin-top: 100px;
        margin-bottom: 50px;
      }
    </style>

  <meta name="generator" content="Hexo 5.4.0"></head>
  <body>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat">
<style type="text/css">
    #header-box {
        width: 70%;
        position: fixed;
        top: 0px;
        left: auto;
        height: auto;
        margin: 0px;
        padding-bottom: 20px;
        background-color: rgb(230, 230, 230);
    }
    #header {
        margin-top: 10px;
        padding: 20px;
        background-color: rgb(255, 250, 230);
    }
    #name {
        font-family: Georgia;
        font-size: 36px;
        font-weight: bold;
        margin: 0px;
    }
    #links {
        position: absolute;
        top: 38px;
        right: 40px;
        width: auto;
    }
    a.link {
        padding-left: 10px;
        font-family: "Montserrat", sans-serif;
        font-size: 20px;
        color: steelblue;
        text-decoration: none;
    }
    a.link:visited {
        text-decoration: none;
    }
</style>
<div id="header-box">
    <div id="header">
        <p id="name">Winter Cyan</p>
        <div id="links">
            <a class="link" href="http://localhost:4000" target="_self">HOME</a>
            <a class="link" style="color: gainsboro;">ARTICLE</a>
            <a class="link" style="color: gainsboro;">ABOUT</a>
        </div>
    </div>
</div>
    <meta http-equiv="Content-Type" content="text/html;charset=gb2321"/>
<style type="text/css">
    img {
        max-width: 1080px;
        max-height: 1080p;
        margin-left: auto;
        margin-right: auto;
    }
    h1 {
        font-family: 'Times New Roman', 'SongTi', Times, serif;
        text-align: center;
        padding: auto;
        margin: auto;
        padding-top: 10px;
        margin-top: 0px;
        margin-bottom: 5px;
        max-width: 70%;
    }
    #before-md {
        background-color: white;
    }
    .article_date {
        text-align: center;
        font-family: "Montserrat", sans-serif;
        margin: 0px;
        margin-top: 5px;
    }
    .md {
        font-family: 'Times New Roman', Times, serif;
        background-color: white;
        padding: 40px;
        padding-top: 1px;
    }
    .md p {
        font-size: 20px;
    }
    hr {
        width: 80%;
    }
</style>

<body class="article-body">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat">
<style type="text/css">
    #header-box {
        width: 70%;
        position: fixed;
        top: 0px;
        left: auto;
        height: auto;
        margin: 0px;
        padding-bottom: 20px;
        background-color: rgb(230, 230, 230);
    }
    #header {
        margin-top: 10px;
        padding: 20px;
        background-color: rgb(255, 250, 230);
    }
    #name {
        font-family: Georgia;
        font-size: 36px;
        font-weight: bold;
        margin: 0px;
    }
    #links {
        position: absolute;
        top: 38px;
        right: 40px;
        width: auto;
    }
    a.link {
        padding-left: 10px;
        font-family: "Montserrat", sans-serif;
        font-size: 20px;
        color: steelblue;
        text-decoration: none;
    }
    a.link:visited {
        text-decoration: none;
    }
</style>
<div id="header-box">
    <div id="header">
        <p id="name">Winter Cyan</p>
        <div id="links">
            <a class="link" href="http://localhost:4000" target="_self">HOME</a>
            <a class="link" style="color: gainsboro;">ARTICLE</a>
            <a class="link" style="color: gainsboro;">ABOUT</a>
        </div>
    </div>
</div> 
    <div id="before-md">
        <br>
        <hr style="background-color: black; height: 4px; border: none; margin-top: 20px;">
        <h1>Learn OpenGL Notes</h1>
        <p class="article_date">2021 05 05</p>
        <hr style="background-color: black; height: 2px; border: none;">
        <br>
    </div>
    <div class="md">
        <h1 id="OpenGL-Notes"><a href="#OpenGL-Notes" class="headerlink" title="OpenGL Notes"></a>OpenGL Notes</h1><h2 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h2><h3 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h3><p><strong>State Machine</strong>: a collection of <strong>variables</strong>, define how OpenGL operate.</p>
<p>​    state: <strong>context</strong></p>
<p>​    change state: set <strong>options</strong>, manipulating <strong>buffers</strong>, <strong>render</strong> using context. e.g., some context variables control TRIANGLE or LINE, and next drawing commands follow that option. <strong>how</strong>: using <strong>state-changing</strong> func or <strong>state-using</strong> func.</p>
<p><strong>Objects</strong>: a collection of <strong>options</strong>, represents a <strong>subset of state</strong>. e.g., a structure(<strong>object</strong>) holds settings of a window.</p>
<p><strong>workflow</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> objectId = <span class="number">0</span>;</span><br><span class="line">glGenObject(<span class="number">1</span>, &amp;objectId); <span class="comment">//create obj, objectId refers to it.</span></span><br><span class="line">glBindObject(GL_WINDOW_TARGET, objectId); <span class="comment">//bind obj to TARGET.</span></span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="number">800</span>); <span class="comment">//change options of TARGET, obj changes too.</span></span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="number">600</span>);</span><br><span class="line">glBindObject(GL_WINDOW_TARGET, <span class="number">0</span>); <span class="comment">//unbind.</span></span><br></pre></td></tr></table></figure>

<h3 id="Creating-a-window"><a href="#Creating-a-window" class="headerlink" title="Creating a window"></a>Creating a window</h3><p><strong>GLFW</strong>: create context, define window, handle input.</p>
<p><strong>GLAD</strong>: manages <strong>func-pointers</strong> for OpenGL.</p>
<h3 id="Hello-Window"><a href="#Hello-Window" class="headerlink" title="Hello Window"></a>Hello Window</h3><p><strong>!!!</strong>: include glad.h <strong>before</strong> glfw3.h</p>
<p><strong>glfwInit()</strong></p>
<p><strong>glfwWindowHint()</strong>, control options such as VERSION**(3)<strong>, PROFILE</strong>(CORE_PROFILE)**. p.s., for OS X, add <strong>glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)</strong></p>
<p>*<em>GLFWWindow <em>window</em></em>, <strong>glfwCreateWindow(WIDTH, HEIGHT, NAME, NULL, NULL)</strong></p>
<p>check if window exists. if not, <strong>glfwTerminate()</strong></p>
<p><strong>glfwMakeContextCurrent(window)</strong>, make context of window the main context on current thread.</p>
<p>init GLAD: check <strong>gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)</strong></p>
<p><strong>glViewport()</strong>, tell OpenGL the size of the rendering window.</p>
<p>window <strong>resize</strong>: define a callback func, register it with <strong>glfwSetFramebufferSizeCallback(window, func)</strong></p>
<p><strong>keep drawing</strong> images&amp;handling input: <strong>render loop</strong>. in loop: <strong>glfwSwapBuffers()</strong> swap the color buffer(contains color values for pixels in window), <strong>glfwPollEvents()</strong> checks if any events are triggered.</p>
<p><strong>glClearColor</strong>&amp;<strong>glClear</strong>: set color.</p>
<h3 id="Hello-Triangle"><a href="#Hello-Triangle" class="headerlink" title="Hello Triangle"></a>Hello Triangle</h3><p>in OpenGL, everything is in <strong>3D</strong> space.</p>
<p><strong>graphics pipeline</strong>: 3D <strong>coordinates</strong> (to 2D coordinates) to 2D <strong>pixels</strong>.</p>
<p><strong>shader</strong>: small programs ruuning in GPU.</p>
<p><strong>GLSL</strong>: OpenGL Shading Language, write shaders.</p>
<p>Vertex Data[] -&gt; <strong>Vertex Shader</strong> -&gt; Shape Assembly -&gt; <strong>Geometry Shader</strong> -&gt; Rasterization -&gt; <strong>Fragment Shader</strong> -&gt; Tests and Blending</p>
<p>![](assets/Screen Shot 2019-08-07 at 7.58.42 AM.png)</p>
<p><strong>primitives</strong>: what kind of render types form with data. <strong>GL_POINTS, GL_TRIANGLES, GL_LINE_STRIP</strong>.</p>
<table>
<thead>
<tr>
<th>Shader</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Vertex Shader</strong></td>
<td>transform 3D coordinates into different 3D coordinates.</td>
</tr>
<tr>
<td>Primitive Assembly</td>
<td>form a primitive, assembles all points.</td>
</tr>
<tr>
<td>Geometry Shader</td>
<td>generate other shapes by emitting new vertices to form new primitives.</td>
</tr>
<tr>
<td>Rasterization</td>
<td>maps the resulting primitives to the corresponding pixels on screen.</td>
</tr>
<tr>
<td><strong>Fragment Shader</strong></td>
<td>calculate the final color of a pixel.</td>
</tr>
<tr>
<td>Alpha Test &amp; Blending</td>
<td>checks depth value, checks alpha values and blends objects.</td>
</tr>
</tbody></table>
<ol>
<li><p>prepare data(<strong>vertices</strong>).</p>
</li>
<li><p>create <strong>VBO</strong>: vertex buffer objects. store a large number of vertices in GPU’s memory. generated by <strong>glGenBuffers()</strong> with id. buffer type: <strong>GL_ARRAY_BUFFER</strong></p>
</li>
<li><p>bind: <strong>glBindBuffer()</strong></p>
</li>
<li><p>copy data into GPU’s memory: <strong>glBufferData()</strong>, to VBO.<br><strong>GL_STATIC_DRAW GL_DYNAMIC_DRAW GL_STREAM_DRAW</strong>, according to frequency of changing of data.</p>
</li>
<li><p>create vertex and fragment <strong>shader</strong>, write with <strong>GLSL</strong> and compile.</p>
<ol>
<li><p><strong>VERTEX</strong> SHADER</p>
<p><strong>code</strong>, in the form of a <strong>const C string</strong> at the top.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core // declare version</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos; <span class="comment">// create input variable and set location.</span></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">	<span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>); <span class="comment">// set gl_Position as output. simple function.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>compile</strong></p>
<ol>
<li>shader <strong>object</strong>, <strong>glCreateShader(GL_VERTEX_SHADER)</strong></li>
<li><strong>attach</strong> shader source code, <strong>glShaderSource()</strong></li>
<li>compile. <strong>glCompileShader()</strong></li>
</ol>
<p><strong>check</strong> compile error</p>
</li>
<li><p><strong>FRAGMENT</strong> SHADER</p>
<p><strong>code</strong></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor; <span class="comment">// define the output</span></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">	FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>f, <span class="number">.5</span>f, <span class="number">.2</span>f, <span class="number">1.0</span>f); <span class="comment">// set output&#x27;s value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>compile</strong></p>
<p><strong>check</strong> compile error</p>
</li>
</ol>
</li>
<li><p>create shader <strong>program</strong>, <strong>glCreateProgram()</strong>, then <strong>attach and link</strong> shaders to it, <strong>glAttachShader()</strong> &amp; <strong>glLinkProgram()</strong>. finally, check linking error.</p>
</li>
<li><p><strong>use</strong> program, <strong>glUseProgram()</strong></p>
</li>
<li><p><strong>delete</strong> the shader objects.</p>
</li>
<li><p><strong>link attributes</strong>, <strong>tell</strong> OpenGL how to <strong>interpret</strong> data and how to <strong>connect</strong> data to <strong>vertex</strong> shader’s attributes. ![](assets/Screen Shot 2019-07-03 at 12.20.08 PM.png)<br><strong>glVertexAttribPointer(<em>position</em>, <em>sizeof attribute</em>, <em>type</em>, <em>normalize</em>, <em>stride</em>, <em>offset</em>)</strong> and <strong>glEnableVertexAttribArray()</strong></p>
</li>
</ol>
<p><strong>VAO</strong>, Vertex Array Object. bound like a VBO, any subsequent vertex attribute will be stored in VAO.</p>
<p>how to <strong>understand</strong> VAO: 所谓的VAO定义了顶点属性 而VBO只是一堆本质上没区别的数据</p>
<p><img src="assets/v2-2f7beaffce2851a26a5bcba77e29120a_r.jpg"></p>
<p>bind VAO -&gt; bind buffer &amp; buffer data -&gt; pointer &amp; enable -&gt; unbind VAO.</p>
<hr>
<p><strong>Questions</strong> about VAO and pointer(attribute).</p>
<ul>
<li><input disabled="" type="checkbox"> why bind VAO before bind buffer &amp; buffer data?</li>
<li><input disabled="" type="checkbox"> how dose VAO effect the way of interpreting vertices and indices(if it dose)?</li>
<li><input disabled="" type="checkbox"> <strong>why it dosen’t work</strong> in <em>rectangle case</em> when place glBindVertexArray() just before glVertexAttribPointer(), <strong>while it dose</strong> in <em>trianlge case</em>?</li>
<li><input disabled="" type="checkbox"> dose pointer effect the way of interpreting indices?</li>
<li><input disabled="" type="checkbox"> what pointer dose effect on?</li>
<li><input disabled="" type="checkbox"> how to understand <em>VAO can be bound just like a vertex buffer object and any subsequent vertex attribute calls from that point on will be stored inside the VAO</em>?</li>
</ul>
<hr>
<p><strong>EBO</strong>, element buffer objects. add a indices[] variable, and replace glDrawArrays with <strong>glDrawElements</strong>. cannot unbind EBO while VAO is active, because the EBO <em>IS BEING STORED</em> in VAO.</p>
<h3 id="Shaders"><a href="#Shaders" class="headerlink" title="Shaders"></a>Shaders</h3><ol>
<li><p>GLSL. <strong>version</strong> declaration -&gt; <strong>in</strong>s and <strong>out</strong>s -&gt; <strong>uniforms</strong> -&gt; <strong>main</strong>. structure:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version ver_number</span></span><br><span class="line"><span class="keyword">in</span> type in1;</span><br><span class="line"><span class="keyword">in</span> type in2;</span><br><span class="line"><span class="keyword">out</span> type <span class="keyword">out</span>;</span><br><span class="line"><span class="keyword">uniform</span> type uni;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">	<span class="keyword">out</span> = <span class="meta">#$%^&amp;*; // process ins to outs.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>types. <strong>vector</strong>: vec1, vec2, …, vec4. bvec1, …, dvec4. v.x, v.y, v.z, v.w. <strong>swizzling</strong>: a.xyxz. ![](assets/Screen Shot 2019-07-04 at 6.27.49 PM.png) ![](assets/Screen Shot 2019-07-04 at 6.28.10 PM.png)</p>
</li>
<li><p>ins and outs. vertex shader -&gt; fragment shader. with the <strong>same type &amp; name</strong>.</p>
</li>
<li><p><strong>uniform</strong>, pass data from <strong>CPU to GPU</strong>. <strong>global</strong>, unique per shader program object and keep value. set value: get <strong>location</strong> with <strong>glGetUnifromLocation()</strong>, then <strong>use</strong> program and lastly <strong>update</strong> the uniform.</p>
</li>
<li><p>vertices with <strong>color</strong>. ![](assets/Screen Shot 2019-07-04 at 11.15.45 PM.png) ![](assets/Screen Shot 2019-07-04 at 11.20.18 PM.png)  ![](assets/Screen Shot 2019-07-04 at 11.15.24 PM.png)<br>different attributes(such as coordinates, colors, etc.) has different location. VAO holds how vertex shader should interpret these attributes.</p>
</li>
<li><p>shader <strong>class</strong>.</p>
<p>![](assets/Screen Shot 2019-07-05 at 7.57.13 AM.png) bottom-left corner’s <strong>black</strong>: position of <strong>-</strong>.i(negative) is <strong>clamped</strong> to 0.0f.</p>
</li>
</ol>
<h3 id="Textures"><a href="#Textures" class="headerlink" title="Textures"></a>Textures</h3><p>texture <strong>coordinate</strong>: range from 0 to 1 in x and y. ![](assets/Screen Shot 2019-07-05 at 2.41.37 PM.png) </p>
<p><strong>sampling</strong>: get texture color using texture coordinates.</p>
<p><strong>wrappinng</strong>: <strong>glTexParameteri(GL_TEXTURE_2D, —, —)</strong> ![](assets/Screen Shot 2019-07-05 at 11.42.37 PM.png)</p>
<p><strong>Filtering</strong>: ![](assets/Screen Shot 2019-07-05 at 11.45.07 PM.png)</p>
<p><strong>Mipmaps</strong>: <strong>glGenerateMipmap(GL_TEXTURE_2D)</strong></p>
<p><strong>create</strong> texture: </p>
<ol>
<li>include <strong>stb_image.h</strong></li>
<li>load picture file with <strong>stbi_load()</strong>, store it in <strong>data</strong></li>
<li><strong>generate &amp; bind</strong> texture.</li>
<li>link with data, <strong>glTexImage2D()</strong></li>
<li>generate <strong>mipmap</strong></li>
<li><strong>free</strong> data</li>
</ol>
<p><strong>apply</strong>: ![](assets/Screen Shot 2019-07-05 at 4.09.27 PM.png)</p>
<ol>
<li>add <strong>vec2</strong> aTexCoord in vertex shader with new location</li>
<li>add <strong>sampler2D</strong> uniform in fragment shader</li>
<li>get sampling color in fragment shader with <strong>texture()</strong></li>
<li>set <strong>pointer</strong> and <strong>enable</strong> it</li>
<li>bind texture in <strong>while</strong> loop before draw</li>
</ol>
<p><strong>texture units</strong>: use more than one textures in shaders.</p>
<p><strong>multiple textures</strong>:</p>
<ol>
<li>add uniform sampler2D in fragment shader</li>
<li>generate texture with data</li>
<li>active and bind texture to TEXTURE<strong>0</strong>(which means, when calling glUniform1i(texture1, <strong>0</strong>), we set texture1 to TEXTURE<strong>0</strong> in shader), TEXTURE1, etc.</li>
<li>set corresponding textures we defined to uniform samplers <strong>after use shader</strong>.</li>
</ol>
<h3 id="Transformations"><a href="#Transformations" class="headerlink" title="Transformations"></a>Transformations</h3><p><strong>GLM</strong>: Open<strong>GL M</strong>athematics.</p>
<p>create <strong>transformation matrix</strong> first, and add a uniform <strong>mat4</strong> in vertex shader; <strong>glUniformMatrix4fv(transLocation, 1, GL_FALSE, glm::value_ptr(trans))</strong>;</p>
<p>transformation: <strong>scale, rotate, translate</strong>.</p>
<h3 id="Coordinate-Systems"><a href="#Coordinate-Systems" class="headerlink" title="Coordinate Systems"></a>Coordinate Systems</h3><p>vertex coordinates: <strong>local -&gt; world -&gt; view -&gt; clip -&gt; screen</strong></p>
<p>![](assets/Screen Shot 2019-07-06 at 5.40.55 PM.png)</p>
<p>three matrix: <strong>model, view, projection</strong> matrices.</p>
<p><strong>3D</strong>: coordinate -&gt; model(<strong>rotate &amp; translate</strong>) -&gt; view(<strong>translate in reverse direction</strong>) -&gt; projection(<strong>perspective</strong>).</p>
<p>![](assets/Screen Shot 2019-07-06 at 10.37.35 PM.png)</p>
<p>OpenGL draws cube triangle-by-triangle. overwrite. <strong>Z-buffer, depth buffer</strong>. enable depth test: <strong>glEnable(GL_DEPTH_TEST)</strong> and in game loop, <strong>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</strong>.</p>
<h3 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h3><p><img src="assets/WechatIMG6-2488906.jpeg"></p>
<p><strong>pos -&gt; +tar&amp;norm(pos-tar) -&gt; dire -&gt; +up&amp;cross(up, dire) -&gt; right&amp;cross(dire, right) -&gt; z</strong>; </p>
<p><strong>lookAt</strong>: pos + tar + up, tar is <strong>pos+front</strong>(keep looking <strong>forward</strong>).</p>
<p><strong>Euler Angles</strong>, 俯仰、偏航、翻滚: three angles to represent 3D rotation, which are <em><strong>pitch</strong></em>, <em><strong>yaw</strong></em> and <em>roll</em>. plane as a model:![](assets/Screen Shot 2019-07-09 at 5.53.12 PM.png)</p>
<p>pitch: up&amp;down, yaw: left or right, roll: roll myself.</p>
<p><img src="assets/WechatIMG7.jpeg"></p>
<p><strong>Mouse Input</strong></p>
<p><strong>capture</strong> cursor: glfwSetInputMode()</p>
<p><strong>jump</strong> adjustment:<img src="assets/WechatIMG8.jpeg"></p>
<h2 id="Lighting"><a href="#Lighting" class="headerlink" title="Lighting"></a>Lighting</h2><h3 id="Colors"><a href="#Colors" class="headerlink" title="Colors"></a>Colors</h3><p>object ***** lamp = final color.</p>
<p>different shader &amp; different VAO, set render method in fragment shader.</p>
<h3 id="Basic-Lighting"><a href="#Basic-Lighting" class="headerlink" title="Basic Lighting"></a>Basic Lighting</h3><p><strong>Phong lighting mode</strong>: <strong>ambient（环境）, diffuse（漫反射）, specular（镜面）</strong>. ![](assets/Screen Shot 2019-07-11 at 6.29.26 PM.png)</p>
<p><strong>Ambient Lighting</strong>: use a ambient_strength parameter to <strong>weaken</strong> lightColor.</p>
<p><strong>Diffuse Lighting</strong>:   𝜃⤴︎, impact of light⤵︎. ![](assets/Screen Shot 2019-07-11 at 6.43.00 PM.png)to get 𝜃, we use <strong>dot product</strong> of  <strong>n</strong> and normalized <strong>v</strong>(light, fragment).</p>
<p><strong>n</strong>: set manually</p>
<p><strong>ray</strong>: lampPos - FragPos</p>
<p><strong>FragPos</strong>: model * position</p>
<p><img src="assets/WechatIMG12.jpeg"></p>
<p>keep normal vectors constant: if we do model * vertices, the normal vector’s coordinates are changed: </p>
<p><strong>Specular Lighting</strong></p>
<p>![](assets/Screen Shot 2019-07-13 at 12.34.02 AM.png)</p>
<p>𝜃⤴︎, impact of light⤵︎.</p>
<p>get reflective: lightDire -&gt; reverse &amp; reflect around Norm. get viewDire: viewPos(cameraPos)-FragPos.</p>
<p>Coordinate translation, form WORLD to VIEW: <strong>view * coord_in_world</strong>.</p>
<h3 id="Materials"><a href="#Materials" class="headerlink" title="Materials"></a>Materials</h3><p>add a <strong>struc Material</strong> in fragment shader, it has 4 comps: ambient, diffuse, specular, which is vec3, and a float shininess. different material attributes can be found <a target="_blank" rel="noopener" href="http://devernay.free.fr/cours/opengl/materials.html">here</a>.</p>
<h3 id="Lighting-Maps"><a href="#Lighting-Maps" class="headerlink" title="Lighting Maps"></a>Lighting Maps</h3><p><strong>Diffuse Maps</strong>: add <strong>texture</strong> to object.</p>
<p>set diffuse &amp; ambient as texture color, replace the object color.</p>
<p><strong>Specular Maps</strong>: just same as diffuse maps.</p>
<p><strong>Emission Maps:</strong> apply it directly.</p>
<h3 id="Light-Casters"><a href="#Light-Casters" class="headerlink" title="Light Casters"></a>Light Casters</h3><p><strong>Directional Light</strong>: 平行光, set lightDire as a constant vector.</p>
<p><strong>Point Light</strong>: set lightDire as FragPos - lampPos;</p>
<p><strong>Attenuation</strong>: ![](assets/Screen Shot 2019-07-17 at 12.39.14 PM.png)</p>
<p>get distance: <strong>length()</strong></p>
<p><strong>Spotlight</strong> &amp; Soft Edge</p>
<p>![](assets/Screen Shot 2019-07-21 at 12.56.05 AM.png)</p>
<p>compare the <strong>cosine</strong> instead of the angle, to reduce calculations. </p>
<p>![](assets/Screen Shot 2019-07-21 at 12.54.43 PM.png)</p>
<p><strong>ε = 𝜙 - γ</strong> (cos(inner) - cos(outer))</p>
<p><strong>I ∊ [0,1]</strong></p>
<h2 id="Model-Loading"><a href="#Model-Loading" class="headerlink" title="Model Loading"></a>Model Loading</h2><h3 id="Assimp"><a href="#Assimp" class="headerlink" title="Assimp"></a>Assimp</h3><p>assimp: <strong>open asset import library</strong>, import data from different formats, and organize them in a <strong>certain style</strong>.</p>
<p>![](assets/Screen Shot 2019-07-23 at 10.42.57 PM.png)</p>
<p><img src="assets/WechatIMG1.jpeg"></p>
<h2 id="Advanced-OpenGL"><a href="#Advanced-OpenGL" class="headerlink" title="Advanced OpenGL"></a>Advanced OpenGL</h2><h3 id="Depth-testing"><a href="#Depth-testing" class="headerlink" title="Depth testing"></a>Depth testing</h3><p>depth: in <strong>in view space</strong>, [0,1]</p>
<p><strong>stores</strong> the z-values of fragment in <strong>z-buffer</strong> if <strong>passed</strong> the test, and discards fragment if test is failed.</p>
<p>gl<strong>Enable</strong>(GL_DEPTH_TEST) &amp; gl<strong>Clear</strong>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</p>
<p>if we want the depth buffer not update: gl<strong>DepthMask</strong>(GL_FALSE)</p>
<p>determine how the test operate: gl<strong>DepthFunc</strong>()</p>
<p>![](assets/Screen Shot 2019-07-28 at 8.44.41 PM.png)</p>
<p><strong>un-linear</strong>: when close by the surface, the distance has a large effect on depth value. so, move a little distance, depth value becomes nearly 1.![](assets/Screen Shot 2019-07-28 at 8.47.53 PM.png)</p>
<p>reverse the depth to linear: ![](assets/Screen Shot 2019-07-28 at 9.05.59 PM.png)</p>
<p><strong>z-fighting</strong>: ![](assets/Screen Shot 2019-07-28 at 9.13.14 PM.png)</p>
<p>both the plane and the bottom of box have z-value <strong>0</strong>, so program <strong>cannot determine</strong> which one is on the top.</p>
<p><strong>prevent z-fighting</strong>:</p>
<ol>
<li>set a offset, so the z-values of planes are different.</li>
<li>make <strong>near</strong> much bigger.</li>
<li>use bigger <strong>depth buffer</strong>.</li>
</ol>
<h3 id="Stencil-testing"><a href="#Stencil-testing" class="headerlink" title="Stencil testing"></a>Stencil testing</h3><p>![](assets/Screen Shot 2019-07-29 at 8.22.45 PM.png)</p>
<p>stencil buffer is like a <strong>mask</strong>, when 1, draw, when 0, discard.</p>
<p><strong>outline</strong>: ![](assets/WechatIMG1 1-4403085.jpeg)</p>
<h3 id="Blending"><a href="#Blending" class="headerlink" title="Blending"></a>Blending</h3><p><strong>glEnable(GL_BLEND)</strong>, glBlendFunc()</p>
<p>![](assets/Screen Shot 2019-07-29 at 10.27.54 PM.png)</p>
<p>![](assets/Screen Shot 2019-07-29 at 10.00.31 PM.png)</p>
<p>draw 1 first, the corner becomes the floor; then draw 2, depth test failed in the corner, so floor displays.</p>
<p>solve: change the <strong>order</strong> of drawing objects, draw far-away objects firstly.</p>
<h3 id="Face-culling"><a href="#Face-culling" class="headerlink" title="Face culling"></a>Face culling</h3><p>determine with winding order of vertices in a triangle.</p>
<p>![](assets/Screen Shot 2019-07-30 at 1.37.07 PM-4465085.png)</p>
<p><strong>re-define</strong> the vertex order in data. then glEnable(<strong>GL_CULL_FACE</strong>).</p>
<h3 id="Framebuffers"><a href="#Framebuffers" class="headerlink" title="Framebuffers"></a>Framebuffers</h3><p>get all pixels in a <strong>frame</strong> and store them in a <strong>texture</strong>(image), then we can do some post-processing on it.</p>
<p>prepare:</p>
<ol>
<li><strong>gen</strong> and <strong>bind</strong> a frame buffer</li>
<li>texture: <strong>create</strong> a texture as color attachment. <strong>bind</strong> it.</li>
<li>render buffer: <strong>gen</strong> and <strong>bind</strong>, as the container for depth and stencil buffer. then <strong>create depth and stencil renderbuffer</strong> and <strong>bind</strong>.</li>
<li>create special <strong>VAO</strong>, <strong>VBO</strong> and <strong>shader</strong> for texture.</li>
</ol>
<p>procedure:</p>
<ol>
<li>bind the <strong>FBO</strong> we created.</li>
<li>clear color and bits, then draw objects as usual with DEPTH_TEST enabled.</li>
<li>bind framebuffer to default one.</li>
<li>clear color and bits, then <strong>bind texture</strong> and <strong>draw</strong> with DEPTH_TEST disabled.</li>
</ol>
<h3 id="Cubemaps"><a href="#Cubemaps" class="headerlink" title="Cubemaps"></a>Cubemaps</h3><p>cubemap: a cube contains 6 textures. <strong>gen</strong> and <strong>bind</strong> a <strong>GL_TEXTURE_CUBE_MAP</strong> texture. in the frag-shader, add a <strong>samplerCube</strong> uniform, and tex-coords = vertices’ position.</p>
<p>bind 6 texture images: ![](assets/Screen Shot 2019-08-01 at 8.12.27 PM.png)</p>
<p>in program, setup the vertices’ postion data, and create corresponding VAO, VBO. when draw the <strong>sky-cube</strong>, keep the view position at the origin: <strong>mat4(mat3(getViewMatrix))</strong>, otherwise, when moving the camera: ![](assets/Screen Shot 2019-08-01 at 8.00.11 PM.png)</p>
<p><strong>optimization</strong>: draw objects firstly, then draw the skybox. when objects finished, the depth-buffer stores the depth values of objects.</p>
<p><strong>to be solved</strong>: </p>
<ul>
<li><input disabled="" type="checkbox"> the depth of objects is less than 1?</li>
<li><input disabled="" type="checkbox"> how the depth value comes? create or modified by view matrix?</li>
<li><input disabled="" type="checkbox"> what is in the depth buffer and where it comes from? and when?</li>
<li><input checked="" disabled="" type="checkbox"> why GL_LEQUAL? shouldn’t it be pass if value &lt; buffer? <strong>it need to fail if buffer &lt; depth-value</strong>, so it is pass if depth-value <strong>&lt;=</strong> buffer. and by the way, all of the left depth is 1.</li>
<li><input disabled="" type="checkbox"> but if set func as LESS, then it fail if buffer &lt;= depth-value, how the black triangle appears?</li>
<li><input disabled="" type="checkbox"> what is early depth testing?</li>
<li><input disabled="" type="checkbox"> why there is the z-fighting problem?</li>
</ul>
<p>![if set func to GL_LESS](assets/Screen Shot 2019-08-01 at 9.15.42 PM.png)</p>
<p>![show the depth value in fs.cube, value = z/w](assets/Screen Shot 2019-08-01 at 9.44.31 PM.png)</p>
<p><strong>reflect</strong> and <strong>refract</strong>: </p>
<p>![](assets/Screen Shot 2019-08-04 at 5.45.30 PM.png)</p>
<p>get the reflect vector <strong>R</strong> with reflect, and sample the skybox with that vector.</p>
<p>![](assets/Screen Shot 2019-08-04 at 5.45.56 PM.png)</p>
<p>get refraction ratio, use func <strong>refract</strong> to get <strong>R</strong>, then sample.</p>
<h3 id="Advanced-Data"><a href="#Advanced-Data" class="headerlink" title="Advanced Data"></a>Advanced Data</h3><p><strong>glBindSubData</strong>, offer a <strong>offset</strong> and a <strong>size</strong>, put data into specific location of buffer. the <strong>glBindData()</strong> is necessary before glBindSubData.</p>
<p>we can decalre and bind our data like this: ![](assets/Screen Shot 2019-08-05 at 3.58.06 PM.png)</p>
<p>the buffer syntax: <strong>pos-pos-…-pos|norm-norm-…-norm|tex-tex-…-tex</strong></p>
<p>and we configure the pointers like this:</p>
<p>![](assets/Screen Shot 2019-08-05 at 4.14.50 PM.png)</p>
<table>
<thead>
<tr>
<th align="center">pointer</th>
<th align="center">data num</th>
<th align="center">stride</th>
<th align="center">offset</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">8*sizeof(float)</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">8*sizeof(float)</td>
<td align="center">3*sizeof(float)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">8*sizeof(float)</td>
<td align="center">6*sizeof(float)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3*sizeof(float)</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">3*sizeof(float)</td>
<td align="center">sizeof(pos-s)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2*sizeof(float)</td>
<td align="center">sizeof(pos-s)+sizeof(norm-s)</td>
</tr>
</tbody></table>
<p><strong>copy buffers</strong>: glCopyBufferSubData(), readtarget(offset) to writetarget(offset), with a size.</p>
<p>copy between same kind of buffer: <strong>glCopyReadBuffer</strong> and <strong>glCopyWriteBuffer</strong>.</p>
<h3 id="Advanced-GLSL"><a href="#Advanced-GLSL" class="headerlink" title="Advanced GLSL"></a>Advanced GLSL</h3><h4 id="build-in-variables"><a href="#build-in-variables" class="headerlink" title="build-in variables"></a>build-in variables</h4><p><strong>gl_PointSize</strong> with glEnable(<strong>GL_PROGRAM_POINT_SIZE</strong>)</p>
<p><strong>gl_VertexID</strong>: when index rendering with EBO, gl_VertexID holds the index of vertex; otherwise, it holds the number of vertices processed.</p>
<p><strong>gl_FragCoord</strong>.x, y, z. split screen: ![](assets/Screen Shot 2019-08-06 at 9.17.35 PM.png)</p>
<p><strong>gl_FrontFacing</strong>: true if the fragment is front-facing, false otherwise.</p>
<p><strong>gl_FragDepth</strong>: we can set the depth-value, but meanwhile we it <strong>disables early depth testing</strong>. but we can declare it as follows: ![](assets/Screen Shot 2019-08-06 at 9.24.03 PM.png)</p>
<p>and the condition: ![](assets/Screen Shot 2019-08-06 at 9.24.29 PM.png)</p>
<h4 id="interface-blocks"><a href="#interface-blocks" class="headerlink" title="interface blocks"></a>interface blocks</h4><p>we can define a block of variables we send &amp; receive between shaders.</p>
<table>
<thead>
<tr>
<th>from</th>
<th>to</th>
</tr>
</thead>
<tbody><tr>
<td>out VAR_NAME {<br />        vars;<br />} name;</td>
<td>in VAR_NAME{<br />        vars;<br />} name;</td>
</tr>
</tbody></table>
<p>the <strong>VAR_NAME</strong> should be the same.</p>
<h4 id="UBO"><a href="#UBO" class="headerlink" title="UBO"></a>UBO</h4><p>ubo: stores all same uniforms in one buffer object</p>
<p>in the shaders, we create one/several uniform specified by <strong>layout (std140)</strong>.</p>
<p>in the program context, we create one/several uniform buffer objects which are bound to <strong>GL_UNIFORM_BUFFER</strong> and allocate memory for them. the size of memory determined by size of uniforms in shader.</p>
<p>we have to connect the UBO and uniforms in shader with <strong>BindPoint</strong>, which can be excute in program, the structure: ![](assets/Screen Shot 2019-08-06 at 8.41.24 PM.png)which means every binding point corresponds to several <strong>same</strong> uniforms, but <strong>only one</strong> UBO. uniform-binding points: specify the uniforms with <strong>BlockIndex</strong>: ![](assets/Screen Shot 2019-08-06 at 9.49.58 PM.png) ![](assets/Screen Shot 2019-08-06 at 9.50.22 PM.png)</p>
<p>then we send uniform data to shaders through UBO, with function <strong>glBufferSubData</strong>.</p>
<p>the size of uniform in <strong>std140</strong>, N for 4Byte: ![](assets/Screen Shot 2019-08-06 at 9.53.00 PM.png) ![](assets/Screen Shot 2019-08-06 at 9.52.30 PM.png)</p>
<h3 id="Geometry-Shader"><a href="#Geometry-Shader" class="headerlink" title="Geometry Shader"></a>Geometry Shader</h3><h3 id="Instancing"><a href="#Instancing" class="headerlink" title="Instancing"></a>Instancing</h3><h3 id="Anti-Aliasing"><a href="#Anti-Aliasing" class="headerlink" title="Anti Aliasing"></a>Anti Aliasing</h3><h2 id="Advanced-Lighting"><a href="#Advanced-Lighting" class="headerlink" title="Advanced Lighting"></a>Advanced Lighting</h2><h3 id="Advanced-Lighting-1"><a href="#Advanced-Lighting-1" class="headerlink" title="Advanced Lighting"></a>Advanced Lighting</h3><p><strong>Blinn-Phong</strong>: use <strong>halfway</strong> vector instead of reflect vector to prevent specular becoming negative.</p>
<p>![](assets/Screen Shot 2019-08-09 at 11.05.54 PM.png)</p>
<p>![](assets/Screen Shot 2019-08-09 at 11.06.22 PM.png)</p>
<p>![](assets/Screen Shot 2019-08-09 at 10.44.53 PM.png)</p>
<p>![](assets/Screen Shot 2019-08-09 at 11.08.55 PM.png)</p>
<h3 id="Gamma-Correction"><a href="#Gamma-Correction" class="headerlink" title="Gamma Correction"></a>Gamma Correction</h3>
    </div>
</body>
    <style type="text/css">
    #footer {
        position: fixed;
        color: gray;
        left:0; bottom: 0;
        padding-top: 10px;
        padding-bottom: 10px;
        width: 100%;
        text-align: center;
        background-color: rgb(230, 230, 230);
    }
    a {
        text-decoration: none;
        color: gray;
    }
    a:visited {
        text-decoration: none;
    }
    a:hover {
        color: blue;
    }
</style>
<footer id="footer">
    <a style="text-decoration: none" target="_blank" rel="noopener" href="https://github.com/WinterCyan">Github</a> | Beihang University | wintercyan98@gmail.com
</footer>
  </body>
</html>
